<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>position</title>

    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        position: relative;
      }
      .position {
        width: 800px;
        height: 1500px;
        border: 1px solid red;
        margin: 0 auto;
      }
      /* 1默认值static */
      .items1 {
        border: 1px solid red;
        width: 100px;
        height: 100px;
        position: static;
        background-color: red;
      }
      /* relative值 相对定位不设置偏移量位置不改变，移动后原来的位置还占着*/
      .items2 {
        border: 1px solid red;
        width: 100px;
        height: 100px;
        position: relative;
        left: 10px;
        top: 10px;
        right: 10px;
        bottom: 10px;
        background-color: green;
        z-index: 1;
      }
      /* absolute  绝对定位 配合relative使用, 开启绝对定位后脱离文档流下面元素会向上移动 */
      .items3 {
        border: 1px solid red;
        width: 100px;
        height: 100px;
        position: absolute;
        background-color: yellow;

        top: 0px;
        right: 0px;
      }
      .fa {
        border: 1px solid red;
        position: relative;
        top: 50px;
        right: 50px;
      }
      .items4 {
        border: 1px solid red;

        white-space: nowrap;
        position: absolute;
        background-color: red;
        left: 50%;
        bottom: calc(100% + 10px);
        transform: translatex(-50%);
        /* margin-left: -27px;居中第二种方法 */

        /* white-space: nowrap;     文字内容不允许换行 */
      }
      .items4 {
        display: none;
      }
      .fa:hover .items4 {
        display: inline-block;
      }

      /* fixed:相对于视口定位 固定在视口某个位置不动，滑动页面对他没有影响 不能与transform元素混用不正交，问题较多少用 */
      .items5 {
        display: flex;
        width: 100px;
        height: 100px;
        justify-content: center;
        align-items: center;
        font-size: 50px;
        border: 5px solid blue;
        position: fixed;
        bottom: 10px;
        left: 200px;
      }
      /* sticky粘滞定位   滑动页面时当没到他时他在文档流中，当快移除页面是，他会粘在最上面 兼容性较差*/

      .sticky {
        width: 800px;
        height: 50px;
        position: sticky;
        top: 0;
        border: 1px solid red;
        background-color: pink;
        z-index: 22;
      }

      /* 哪些情况符合层叠上下文：
文档根元素（<html>）；
position 值为 absolute（绝对定位）或  relative（相对定位）且 z-index 值不为 auto 的元素；
position 值为 fixed（固定定位）或 sticky（粘滞定位）的元素（沾滞定位适配所有移动设备上的浏览器，但老的桌面浏览器不支持）；
flex (flexbox) 容器的子元素，且 z-index 值不为 auto；
grid (grid) 容器的子元素，且 z-index 值不为 auto；
opacity 属性值小于 1 的元素（参见 the specification for opacity）；
mix-blend-mode 属性值不为 normal 的元素；
以下任意属性值不为 none 的元素：
transform
filter
perspective
clip-path
mask / mask-image / mask-border
isolation 属性值为 isolate 的元素；
-webkit-overflow-scrolling 属性值为 touch 的元素；
will-change 值设定了任一属性而该属性在 non-initial 值时会创建层叠上下文的元素（参考这篇文章）；
contain 属性值为 layout、paint 或包含它们其中之一的合成值（比如 contain: strict、contain: content）的元素。
在层叠上下文中，子元素同样也按照上面解释的规则进行层叠。 重要的是，其子级层叠上下文的 z-index 值只在父级中才有意义。子级层叠上下文被自动视为父级层叠上下文的一个独立单元。

总结:

层叠上下文可以包含在其他层叠上下文中，并且一起创建一个层叠上下文的层级。
每个层叠上下文都完全独立于它的兄弟元素：当处理层叠时只考虑子元素。
每个层叠上下文都是自包含的：当一个元素的内容发生层叠后，该元素将被作为整体在父级层叠上下文中按顺序进行层叠。
Note: 层叠上下文的层级是 HTML 元素层级的一个子级，因为只有某些元素才会创建层叠上下文。可以这样说，没有创建自己的层叠上下文的元素会被父层叠上下文同化。
      */
    </style>
  </head>
  <body>
    <div class="position">
      <div class="items1"></div>
      <div class="items2"></div>
      <div class="items3"></div>
      <button class="fa">
        点击
        <span class="items4">提示内容</span>
      </button>

      <div class="items5">
        <div class="bb">😍</div>
      </div>
      <div class="sticky"></div>
    </div>
  </body>
</html>
